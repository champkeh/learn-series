# 正则表达式


> 辅助工具: https://regex101.com/


## 是什么东西？

可以认为是一种语言，就像普通的编程语言一样(js/java/go)，有自己的专用语法。

## 可以用来做什么？

匹配文本

1. **校验** 给定文本(字符串)是否符合特定模式
2. **提取** 文本中符合特定模式的内容
3. **处理** 文本数据



## 语法

```text
/pattern/flags
```

- `pattern` 模式
- `flags` 选项



## `flags`

- i: 匹配过程中忽略大小写
- g: 搜索时会查找所有的匹配项，而不只是第一个
- m: 多行模式 (会影响锚点`^$`的匹配行为)
- s: `dotall`模式 (实现真正意义上的匹配所有字符)(**新增，IE不支持**)
- u: 开启 `unicode` 支持(**IE不支持 unicode 属性**)
- y: 粘滞模式 (很少用到)

> 关于 unicode
>
> 唯一可能会用到的就是匹配汉字，采用 `/\p{sc=Han}/u`


## `pattern` 中可以使用的模式

### 字符类

就像集合一样，可以用来匹配一个集合中的任何符号。

已经存在的字符类有：

- 表示数字的字符类: `\d` (digit，表示数字0-9)
- 表示空格的字符类: `\s` (space，表示空格、tab、换行等)
- 表示拉丁字母/数字/下划线的字符类: `\w` (word，拉丁字母a-z，0-9，_)

### 反向字符类

上面的字符类取反的意思

已经存在的反向字符类有:

- 表示非数字的字符类: `\D` (除了 `\d` 以外的任意字符)
- 表示非空格的字符类: `\S` (除了 `\s` 以外的任意字符)
- 表示。。。。     : `\W` (除了 `\w` 以外的任意字符)


### 集合

和字符类相似，可以手动指定该集合包含哪些符号。

比如，上面的字符类 `\d` 就等价于 `[0-9]`，`\w` 就等价于 `[a-zA-Z0-9_]`

然后，你还可以自己定义哪些字符组成一个集合，比如
`[aeiou]` 只包含这5个字符

> 注意
>
> 1. 集合和字符类一样，在匹配的时候只能匹配其中的一个字符
> 2. [] 中的大部分字符都不需要转义，除了那些在特定位置有特殊意义的字符，比如开头的`^`，位于字符中间的`-`

### 反向集合

和反向字符类的概念类似，就是排除集合指定的字符以外的任意符号。

比如，`[^0-9]` 就表示除了 0-9 以外的任意符号。
其实，是等价于 `\D` 的。

### `.`

匹配任意字符(除换行符(`\n`))

> 对于IE不支持 `s` 选项的问题，有替代方案
>
> `/./s`
> 等价于
> `/[\d\D]/`

### unicode 属性

比如，匹配中文: `/\p{sc=Han}/u`


## 量词

表示对特定模式重复多次

### `+`
表示前面的模式出现1次或多次(>=1)
`{1,}`

### `*`
表示前面的模式出现0次或多次(>=0)
`{0,}`

### `?`
表示前面的模式出现0次或1次(可选, <=1)
`{0,1}`

### `{n}`
表示前面的模式出现 `n` 次(=n)

### `{m,n}`
表示前面的模式出现次数在m和n之间(>=m, <=n)

### `{m,}`
`>=m`

### `{,n}`
`<=n`

> 注意
>
> 使用量词的时候要注意，量词默认是 **贪婪** 模式。也就是说，会尽可能多的匹配字符。要关掉 **贪婪** 模式，
> 需要在量词后面使用 `?`
>
> 比如，`"hello" world "hello"` `/".+"/`  
> 可以使用 `/".+?""/` 正确的匹配到
>
> 另一种解决贪婪的方法是采用反向集合：
> `/"[^"]+"/`


## 锚点
表示一个特定的位置，本身不匹配任何字符。

现有的锚点：

- `^` 表示文本开头
- `$` 表示文本结尾

比如，`^$` 就表示空字符串 `""`

> 扩展
>
> `$^` 也表示空字符串 `""`  
>  多行模式(`m`)会影响匹配行为

- `\b` 表示词边界 (主要用于英文单词)


## 断言(环视)

> 英文叫 look ahead / look behind  
> 分别对应 前瞻断言 / 后瞻断言

### 前瞻肯定断言

语法: `x(?=y)`

表示只有当 `x` 后面跟着 `y` 时，才会匹配 `x`

### 前瞻否定断言

语法: `x(?!y)`

表示只有当 `x` 后面不是 `y` 的时候，才会匹配 `x`

### 后瞻肯定断言

语法: `(?<=y)x`

### 后瞻否定断言

语法: `(?<!y)x`


## 捕获组

使用括号 `()` 将模式的一部分包起来，就组成了一个捕获组

捕获组有2个作用：

1. 可以将 `()` 中的内容作为匹配结果输出
2. 可以把一部分模式作为一个整体来使用量词

### 嵌套组

组的编号是根据开括号(`(`)的位置决定的

### 命名组

采用编号的组可读性比较差，所以才有了命名组

语法：`/(?<name>x)/`

比如，想要匹配一个 `2020-12-01` 这样的日期，并且提取出里面的年月日

`/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/`


### 非捕获组

语法: `(?:x)+`

主要是为了想使用量词，但又不希望匹配结果中把它作为单独一个组



## 反向引用

有时候，我们想要在正则表达式内部去引用前面的某一个分组

语法：

- `\N` 引用普通组
- `\k<name>` 引用命名组

> 这个反向引用有什么用处？
>
> 在某些常见下，只能采用反向引用才能解决问题。
>
> 比如，想要匹配出一段文本中的字符串，既要匹配出单引号括起来的字符串，也要匹配出双引号括起来的字符串。
>
> 不能简单的采用下面这样的正则:  
> `/(['"]).*?\1/`  
> `/(?<quote>['"]).*?\k<quote>/`


## 或 (`|`)

语法: `x|y`

优先级比较低


## 回溯

可以参考 https://zh.javascript.info/regexp-catastrophic-backtracking 去理解为什么会产生回溯，已经如何避免回溯。



## 参考资料

- https://zh.javascript.info/regular-expressions
- https://www.regular-expressions.info/tutorial.html
- https://mp.weixin.qq.com/s?__biz=MzI0MDYzOTEyOA==&mid=2247483694&idx=1&sn=e79f23c86e48b6a85d30d612e1d5a2eb&chksm=e9168cd9de6105cf647ceabac1a2ee737d0867e7b3cdab243e3cd889b295e3ab9666820ad02d
- https://juejin.cn/post/6844903724834357261
